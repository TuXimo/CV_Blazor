@using CV_Blazor.Services
@using CV_Blazor.Models

@inject SkillService SkillService

<h2 class="text-center mb-4">Skills</h2>

<div class="skills-main-container">
    <div class="skills-icons">
        @if (SkillsList != null)
        {
            @foreach (var skill in SkillsList)
            {
                <div class="skill-icon-container" style="top:@skill.TopPx; left:@skill.LeftPx;">
                    <img src="@skill.IconPath" alt="@skill.Name"
                         @onmouseover="@(() => ShowSkill(skill))"
                         @onclick="@(() => OnClickSkill(skill))" />
                </div>
            }
        }
    </div>

    <div class="skills-details">
        @if (CurrentSkill != null)
        {
            <h3>@CurrentSkill.Name</h3>
            <p><strong>Level:</strong> @CurrentSkill.Proficiency</p>
            <p>@CurrentSkill.Description</p>
        }
    </div>
</div>

@code {
    private List<SkillPositioned> SkillsList;
    private SkillPositioned CurrentSkill;
    private bool _isClickActive = false; // Nuevo estado para bloquear el hover

    // Dimensiones del contenedor de íconos
    private const int ContainerWidth = 320;
    private const int ContainerHeight = 220;
    private const int IconSize = 80;

    protected override async Task OnInitializedAsync()
    {
        var skills = await SkillService.GetSkillsAsync();
        var rand = new Random();
        var placedSkills = new List<SkillPositioned>();

        foreach (var skill in skills)
        {
            var newPosition = GetNonOverlappingPosition(placedSkills, rand);
            if (newPosition != null)
            {
                var newSkill = new SkillPositioned
                {
                    Name = skill.Name,
                    IconPath = skill.IconPath,
                    Proficiency = skill.Proficiency,
                    Description = skill.Description,
                    TopPx = $"{newPosition.Item1}px",
                    LeftPx = $"{newPosition.Item2}px"
                };
                placedSkills.Add(newSkill);
            }
        }
        SkillsList = placedSkills;

        // Establecer la primera habilidad como predeterminada
        if (SkillsList.Any())
        {
            CurrentSkill = SkillsList.First();
        }
    }

    private void ShowSkill(SkillPositioned skill)
    {
        // Solo actualiza la habilidad si no hay un clic activo
        if (!_isClickActive)
        {
            CurrentSkill = skill;
        }
    }

    private async Task OnClickSkill(SkillPositioned skill)
    {
        // Si ya hay un clic activo, no hacer nada
        if (_isClickActive) return;

        _isClickActive = true;
        CurrentSkill = skill;

        // Espera 1 segundo para "bloquear" el hover
        await Task.Delay(1000);

        // Libera el bloqueo
        _isClickActive = false;
    }

    private Tuple<int, int> GetNonOverlappingPosition(List<SkillPositioned> placedSkills, Random rand)
    {
        const int maxAttempts = 50;
        for (int i = 0; i < maxAttempts; i++)
        {
            int top = rand.Next(0, ContainerHeight - IconSize);
            int left = rand.Next(0, ContainerWidth - IconSize);

            bool isOverlapping = false;
            foreach (var existingSkill in placedSkills)
            {
                int existingTop = int.Parse(existingSkill.TopPx.Replace("px", ""));
                int existingLeft = int.Parse(existingSkill.LeftPx.Replace("px", ""));

                if (
                    left < existingLeft + IconSize &&
                    left + IconSize > existingLeft &&
                    top < existingTop + IconSize &&
                    top + IconSize > existingTop
                )
                {
                    isOverlapping = true;
                    break;
                }
            }

            if (!isOverlapping)
            {
                return new Tuple<int, int>(top, left);
            }
        }

        return null;
    }

    // Clase auxiliar para posiciones
    private class SkillPositioned : Skill
    {
        public string TopPx { get; set; }
        public string LeftPx { get; set; }
    }
}