@using CV_Blazor.Services
@using CV_Blazor.Models

@inject SkillService SkillService

<section id="skills" class="container py-5">
    <h2 class="text-center mb-4">Skills</h2>

    <div class="skills-main-container">
        <div class="skills-icons">
            @if (SkillsList != null)
            {
                @foreach (var skill in SkillsList)
                {
                    <div class="skill-icon-container">
                        <img src="@skill.IconPath" alt="@skill.Name"
                             @onmouseover="@(() => ShowSkill(skill))"
                             @onclick="@(() => OnClickSkill(skill))" />
                    </div>
                }
            }
        </div>

        <div class="skills-details">
            @if (CurrentSkill != null)
            {
                <h3>@CurrentSkill.Name</h3>

                <div class="skill-level">
                    @for (int i = 1; i <= 5; i++)
                    {
                        <span class="level-block @(i <= CurrentSkill.Proficiency ? "filled" : "empty")"></span>
                    }
                </div>

                <p>@CurrentSkill.Description</p>
            }
        </div>

    </div>
</section>

@code {
    private List<Skill> SkillsList;
    private Skill CurrentSkill;
    private bool _isClickActive = false;

    protected override async Task OnInitializedAsync()
    {
        SkillsList = (await SkillService.GetSkillsAsync()).ToList();

        // Establecer la primera habilidad como predeterminada
        if (SkillsList.Any())
        {
            CurrentSkill = SkillsList.First();
        }
    }

    private void ShowSkill(Skill skill)
    {
        if (!_isClickActive)
        {
            CurrentSkill = skill;
        }
    }

    private async Task OnClickSkill(Skill skill)
    {
        if (_isClickActive) return;

        _isClickActive = true;
        CurrentSkill = skill;

        await Task.Delay(1000);

        _isClickActive = false;
    }

    // La clase SkillPositioned y el método GetNonOverlappingPosition ya no son necesarios
}