@using CV_Blazor.Services
@using CV_Blazor.Models

@inject SkillService SkillService
@implements IDisposable

<section id="skills" class="container py-5">
    <h2 class="text-center mb-4">Skills</h2>
    <div class="skills-main-container">

        @* Left side for the moving icons *@
        <div class="skills-icons-animation-area">
            @if (SkillsWithPosition != null)
            {
                @foreach (var skill in SkillsWithPosition)
                {
                    <div class="skill-icon-container"
                         style="left: @(skill.X)px; top: @(skill.Y)px;"
                         @onmouseover="@(() => OnHoverSkill(skill))"
                         @onmouseout="@(() => OnMouseOutSkill())">
                        <img src="@skill.IconPath" alt="@skill.Name" />
                    </div>
                }
            }
        </div>

        @* Right side for the details *@
        <div class="skills-details">
            @if (CurrentSkill != null)
            {
                <h3>@CurrentSkill.Name</h3>
                <div class="skill-level">
                    @for (int i = 1; i <= 5; i++)
                    {
                        <span class="level-block @(i <= CurrentSkill.Proficiency ? "filled" : "empty")"></span>
                    }
                </div>
                <p>@CurrentSkill.Description</p>
            }
        </div>

    </div>
</section>

@code {
    private List<SkillWithPosition> SkillsWithPosition;
    private Skill CurrentSkill;
    private System.Threading.Timer _timer;
    private SkillWithPosition _hoveredSkill = null;

    private const int AnimationWidth = 600;
    private const int AnimationHeight = 400;
    private const int IconSize = 80;

    private class SkillWithPosition : Skill
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Dx { get; set; }
        public double Dy { get; set; }
        public double OriginalDx { get; set; }
        public double OriginalDy { get; set; }
    }

    protected override async Task OnInitializedAsync()
    {
        var skills = (await SkillService.GetSkillsAsync()).ToList();

        SkillsWithPosition = skills.Select(s =>
        {
            var skill = new SkillWithPosition
            {
                Name = s.Name,
                IconPath = s.IconPath,
                Description = s.Description,
                Proficiency = s.Proficiency,
                X = new Random().Next(IconSize / 2, AnimationWidth - IconSize / 2),
                Y = new Random().Next(IconSize / 2, AnimationHeight - IconSize / 2)
            };
            skill.Dx = skill.OriginalDx = (new Random().NextDouble() * 2 - 1) * 2;
            skill.Dy = skill.OriginalDy = (new Random().NextDouble() * 2 - 1) * 2;
            return skill;
        }).ToList();

        if (SkillsWithPosition.Any())
        {
            CurrentSkill = SkillsWithPosition.First();
        }

        _timer = new System.Threading.Timer(UpdatePositions, null, 0, 16);
    }

    private void UpdatePositions(object state)
    {
        foreach (var skill in SkillsWithPosition)
        {
            if (skill != _hoveredSkill)
            {
                // Smoothly return to original speed if a high velocity was applied
                double decelerationFactor = 0.95;
                if (Math.Abs(skill.Dx) > Math.Abs(skill.OriginalDx) || Math.Abs(skill.Dy) > Math.Abs(skill.OriginalDy))
                {
                    skill.Dx = (skill.Dx * decelerationFactor) + (skill.OriginalDx * (1 - decelerationFactor));
                    skill.Dy = (skill.Dy * decelerationFactor) + (skill.OriginalDy * (1 - decelerationFactor));
                }

                // Update position
                skill.X += skill.Dx;
                skill.Y += skill.Dy;

                // Boundary correction to prevent sticking
                if (skill.X <= 0)
                {
                    skill.X = 0;
                    skill.Dx = Math.Abs(skill.Dx);
                    if (Math.Abs(skill.Dx) < Math.Abs(skill.OriginalDx)) skill.Dx = skill.OriginalDx;
                }
                else if (skill.X >= AnimationWidth - IconSize)
                {
                    skill.X = AnimationWidth - IconSize;
                    skill.Dx = -Math.Abs(skill.Dx);
                    if (Math.Abs(skill.Dx) < Math.Abs(skill.OriginalDx)) skill.Dx = -skill.OriginalDx;
                }

                if (skill.Y <= 0)
                {
                    skill.Y = 0;
                    skill.Dy = Math.Abs(skill.Dy);
                    if (Math.Abs(skill.Dy) < Math.Abs(skill.OriginalDy)) skill.Dy = skill.OriginalDy;
                }
                else if (skill.Y >= AnimationHeight - IconSize)
                {
                    skill.Y = AnimationHeight - IconSize;
                    skill.Dy = -Math.Abs(skill.Dy);
                    if (Math.Abs(skill.Dy) < Math.Abs(skill.OriginalDy)) skill.Dy = -skill.OriginalDy;
                }
            }
        }
        InvokeAsync(StateHasChanged);
    }

    private async Task OnHoverSkill(SkillWithPosition hoveredSkill)
    {
        if (_hoveredSkill == hoveredSkill) return;

        _hoveredSkill = hoveredSkill;
        CurrentSkill = hoveredSkill;

        // Stop the hovered skill immediately
        _hoveredSkill.Dx = 0;
        _hoveredSkill.Dy = 0;

        foreach (var skill in SkillsWithPosition)
        {
            if (skill != hoveredSkill)
            {
                double distanceX = skill.X - hoveredSkill.X;
                double distanceY = skill.Y - hoveredSkill.Y;
                double distance = Math.Sqrt(distanceX * distanceX + distanceY * distanceY);

                if (distance > 0 && distance < 150)
                {
                    double explosionForce = 150 / distance;
                    skill.Dx = (distanceX / distance) * explosionForce;
                    skill.Dy = (distanceY / distance) * explosionForce;
                }
            }
        }
    }

    private void OnMouseOutSkill()
    {
        if (_hoveredSkill != null)
        {
            // Reset the hovered skill's velocity to its original state
            _hoveredSkill.Dx = _hoveredSkill.OriginalDx;
            _hoveredSkill.Dy = _hoveredSkill.OriginalDy;
            _hoveredSkill = null;
        }
    }

    public void Dispose()
    {
        _timer?.Dispose();
    }
}