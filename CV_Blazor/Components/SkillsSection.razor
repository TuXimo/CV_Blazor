@using CV_Blazor.Services
@using CV_Blazor.Models
@using System.Globalization
@using Microsoft.Extensions.Localization

@inject SkillService SkillService
@inject LocalizationService LocService
@inject IStringLocalizer<Resources> Localizer

@implements IDisposable

<h2 class="section-title">@Localizer["nav_Skills"]</h2>

<section id="skills" class="container py-5">
    <div class="skills-main-container">

        @* Lado izquierdo para los iconos en movimiento *@
        <div class="skills-icons-animation-area">
            @if (SkillsWithPosition != null)
            {
                @foreach (var skill in SkillsWithPosition)
                {
                    <div class="skill-icon-container"
                                      style="left: @(FormatDouble(skill.X))px; top: @(FormatDouble(skill.Y))px;"
                                      @onmouseover="@(() => OnHoverSkill(skill))"
                                      @onmouseout="@(() => OnMouseOutSkill())">
                        <img src="@skill.IconPath" alt="@skill.Name" />
                    </div>
                }
            }
        </div>

        @* Lado derecho para los detalles de la habilidad *@
        <div class="skills-details">
            @if (CurrentSkill != null)
            {
                <div class="skill-details-content animated-fade-in">
                    <h3 class="skill-title">@CurrentSkill.Name</h3>

                    @* Nivel de habilidad en texto *@
                    <p class="skill-level-text">Nivel: @(GetProficiencyText(CurrentSkill.Proficiency))</p>

                    @* Cuadros de nivel rectangulares y discretos *@
                    <div class="skill-level">
                        @for (int i = 1; i <= 5; i++)
                        {
                            <span class="level-block @(i <= CurrentSkill.Proficiency ? "filled" : "empty")"></span>
                        }
                    </div>
                    <p class="skill-description">@CurrentSkill.Description</p>
                </div>
            }
        </div>

    </div>
</section>

@code {
    private List<SkillWithPosition> SkillsWithPosition;
    private Skill CurrentSkill;
    private System.Threading.Timer _timer;
    private SkillWithPosition _hoveredSkill = null;

    private const int AnimationWidth = 600;
    private const int AnimationHeight = 400;
    private const int IconSize = 80;

    private class SkillWithPosition : Skill
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Dx { get; set; }
        public double Dy { get; set; }
        public double OriginalDx { get; set; }
        public double OriginalDy { get; set; }
    }

    protected override async Task OnInitializedAsync()
    {
        LocService.OnChange += StateHasChanged;
        var skills = (await SkillService.GetSkillsAsync()).ToList();

        SkillsWithPosition = skills.Select(s =>
        {
            var skill = new SkillWithPosition
            {
                Name = s.Name,
                IconPath = s.IconPath,
                Description = s.Description,
                Proficiency = s.Proficiency,
                X = new Random().Next(IconSize / 2, AnimationWidth - IconSize / 2),
                Y = new Random().Next(IconSize / 2, AnimationHeight - IconSize / 2)
            };
            skill.Dx = skill.OriginalDx = (new Random().NextDouble() * 2 - 1) * 2;
            skill.Dy = skill.OriginalDy = (new Random().NextDouble() * 2 - 1) * 2;
            return skill;
        }).ToList();

        if (SkillsWithPosition.Any())
        {
            CurrentSkill = SkillsWithPosition.First();
        }

        _timer = new System.Threading.Timer(UpdatePositions, null, 0, 16);
    }

    private void UpdatePositions(object state)
    {
        foreach (var skill in SkillsWithPosition)
        {
            if (skill != _hoveredSkill)
            {
                double decelerationFactor = 0.95;
                if (Math.Abs(skill.Dx) > Math.Abs(skill.OriginalDx) || Math.Abs(skill.Dy) > Math.Abs(skill.OriginalDy))
                {
                    skill.Dx = (skill.Dx * decelerationFactor) + (skill.OriginalDx * (1 - decelerationFactor));
                    skill.Dy = (skill.Dy * decelerationFactor) + (skill.OriginalDy * (1 - decelerationFactor));
                }

                skill.X += skill.Dx;
                skill.Y += skill.Dy;

                if (skill.X <= 0)
                {
                    skill.X = 0;
                    skill.Dx = Math.Abs(skill.Dx);
                    if (Math.Abs(skill.Dx) < Math.Abs(skill.OriginalDx)) skill.Dx = skill.OriginalDx;
                }
                else if (skill.X >= AnimationWidth - IconSize)
                {
                    skill.X = AnimationWidth - IconSize;
                    skill.Dx = -Math.Abs(skill.Dx);
                    if (Math.Abs(skill.Dx) < Math.Abs(skill.OriginalDx)) skill.Dx = -skill.OriginalDx;
                }

                if (skill.Y <= 0)
                {
                    skill.Y = 0;
                    skill.Dy = Math.Abs(skill.Dy);
                    if (Math.Abs(skill.Dy) < Math.Abs(skill.OriginalDy)) skill.Dy = skill.OriginalDy;
                }
                else if (skill.Y >= AnimationHeight - IconSize)
                {
                    skill.Y = AnimationHeight - IconSize;
                    skill.Dy = -Math.Abs(skill.Dy);
                    if (Math.Abs(skill.Dy) < Math.Abs(skill.OriginalDy)) skill.Dy = -skill.OriginalDy;
                }
            }
        }
        InvokeAsync(StateHasChanged);
    }

    private async Task OnHoverSkill(SkillWithPosition hoveredSkill)
    {
        if (_hoveredSkill == hoveredSkill) return;

        _hoveredSkill = hoveredSkill;
        CurrentSkill = hoveredSkill;

        _hoveredSkill.Dx = 0;
        _hoveredSkill.Dy = 0;

        foreach (var skill in SkillsWithPosition)
        {
            if (skill != hoveredSkill)
            {
                double distanceX = skill.X - hoveredSkill.X;
                double distanceY = skill.Y - hoveredSkill.Y;
                double distance = Math.Sqrt(distanceX * distanceX + distanceY * distanceY);

                if (distance > 0 && distance < 150)
                {
                    double explosionForce = 150 / distance;
                    skill.Dx = (distanceX / distance) * explosionForce;
                    skill.Dy = (distanceY / distance) * explosionForce;
                }
            }
        }
    }

    private void OnMouseOutSkill()
    {
        if (_hoveredSkill != null)
        {
            _hoveredSkill.Dx = _hoveredSkill.OriginalDx;
            _hoveredSkill.Dy = _hoveredSkill.OriginalDy;
            _hoveredSkill = null;
        }
    }

    public void Dispose()
    {
        LocService.OnChange -= StateHasChanged;
        _timer?.Dispose();
    }

    private string GetProficiencyText(int proficiency)
    {
        switch (proficiency)
        {
            case 1: return "Básico";
            case 2: return "Principiante";
            case 3: return "Intermedio";
            case 4: return "Avanzado";
            case 5: return "Experto";
            default: return "Sin definir";
        }
    }

    private string FormatDouble(double value)
    {
        return value.ToString(CultureInfo.InvariantCulture);
    }
}